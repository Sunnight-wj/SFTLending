{
  "address": "0xF2d02e288Bb28D7dbB3FbBb2a4876199A98A06d1",
  "abi": [
    {
      "inputs": [],
      "name": "HEALTH_FACTOR_LIQUIDATION_THRESHOLD",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "totalCollateral",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalDebt",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "ltv",
          "type": "uint256"
        }
      ],
      "name": "calculateAvailableBorrow",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0xdab72939522d251eaa1dcea82f6fdf4c49cc3aa5693afcc82c7cfdfb1bab105d",
  "receipt": {
    "to": null,
    "from": "0x49554923b9361e158Fb267B436f843a4f537D53a",
    "contractAddress": "0xF2d02e288Bb28D7dbB3FbBb2a4876199A98A06d1",
    "transactionIndex": 2,
    "gasUsed": "186472",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa1f6ba5717316118e33c195f340b98e54ee866ee284198ce8756da8f33e791e3",
    "transactionHash": "0xdab72939522d251eaa1dcea82f6fdf4c49cc3aa5693afcc82c7cfdfb1bab105d",
    "logs": [],
    "blockNumber": 30815984,
    "cumulativeGasUsed": "2202402",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "516813ffcda9f29a5ad99ec0e22b25cd",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"HEALTH_FACTOR_LIQUIDATION_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ltv\",\"type\":\"uint256\"}],\"name\":\"calculateAvailableBorrow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"calculateAvailableBorrow(uint256,uint256,uint256)\":{\"details\":\"Calculates the equivalent amount in ETH that an user can borrow, depending on the available collateral and the average Loan To Value\",\"params\":{\"ltv\":\"The loan to value\",\"totalCollateral\":\"The total SFT amount as collateral\",\"totalDebt\":\"The total borrow balance\"},\"returns\":{\"_0\":\"the amount available FIL to borrow for the user*\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/lendingpool/logic/GenericLogic.sol\":\"GenericLogic\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x58b21219689909c4f8339af00813760337f7e2e7f169a97fe49e2896dcfb3b9a\",\"license\":\"MIT\"},\"contracts/helper/PercentageMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.9;\\r\\n\\r\\n/**\\r\\n * @title PercentageMath library\\r\\n * @notice Provides functions to perform percentage calculations\\r\\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\\r\\n * @dev Operations are rounded half up\\r\\n **/\\r\\n\\r\\nlibrary PercentageMath {\\r\\n  uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\\r\\n  uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\\r\\n\\r\\n  /**\\r\\n   * @dev Executes a percentage multiplication\\r\\n   * @param value The value of which the percentage needs to be calculated\\r\\n   * @param percentage The percentage of the value to be calculated\\r\\n   * @return The percentage of value\\r\\n   **/\\r\\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) {\\r\\n    if (value == 0 || percentage == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    require(\\r\\n      value <= (type(uint256).max - HALF_PERCENT) / percentage,\\r\\n      \\\"MULTIPLICATION_OVERFLOW\\\"\\r\\n    );\\r\\n\\r\\n    return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Executes a percentage division\\r\\n   * @param value The value of which the percentage needs to be calculated\\r\\n   * @param percentage The percentage of the value to be calculated\\r\\n   * @return The value divided the percentage\\r\\n   **/\\r\\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) {\\r\\n    require(percentage != 0, \\\"MATH_DIVISION_BY_ZERO\\\");\\r\\n    uint256 halfPercentage = percentage / 2;\\r\\n\\r\\n    require(\\r\\n      value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR,\\r\\n      \\\"MULTIPLICATION_OVERFLOW\\\"\\r\\n    );\\r\\n\\r\\n    return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0xad1b7bc18889bfa1d4b4ccf4b0470ce6d4f8b498eadcfa1910b5307f6ebe86b1\",\"license\":\"MIT\"},\"contracts/helper/WadRayMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.9;\\r\\n\\r\\n/**\\r\\n * @title WadRayMath library\\r\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\r\\n **/\\r\\n\\r\\nlibrary WadRayMath {\\r\\n  uint256 internal constant WAD = 1e18;\\r\\n  uint256 internal constant halfWAD = WAD / 2;\\r\\n\\r\\n  uint256 internal constant RAY = 1e27;\\r\\n  uint256 internal constant halfRAY = RAY / 2;\\r\\n\\r\\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\\r\\n\\r\\n  /**\\r\\n   * @return One ray, 1e27\\r\\n   **/\\r\\n  function ray() internal pure returns (uint256) {\\r\\n    return RAY;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return One wad, 1e18\\r\\n   **/\\r\\n\\r\\n  function wad() internal pure returns (uint256) {\\r\\n    return WAD;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return Half ray, 1e27/2\\r\\n   **/\\r\\n  function halfRay() internal pure returns (uint256) {\\r\\n    return halfRAY;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return Half ray, 1e18/2\\r\\n   **/\\r\\n  function halfWad() internal pure returns (uint256) {\\r\\n    return halfWAD;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Multiplies two wad, rounding half up to the nearest wad\\r\\n   * @param a Wad\\r\\n   * @param b Wad\\r\\n   * @return The result of a*b, in wad\\r\\n   **/\\r\\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    if (a == 0 || b == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    require(a <= (type(uint256).max - halfWAD) / b, \\\"MULTIPLICATION_OVERFLOW\\\");\\r\\n\\r\\n    return (a * b + halfWAD) / WAD;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Divides two wad, rounding half up to the nearest wad\\r\\n   * @param a Wad\\r\\n   * @param b Wad\\r\\n   * @return The result of a/b, in wad\\r\\n   **/\\r\\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b != 0, \\\"DIVISION_BY_ZERO\\\");\\r\\n    uint256 halfB = b / 2;\\r\\n\\r\\n    require(a <= (type(uint256).max - halfB) / WAD, \\\"MULTIPLICATION_OVERFLOW\\\");\\r\\n\\r\\n    return (a * WAD + halfB) / b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Multiplies two ray, rounding half up to the nearest ray\\r\\n   * @param a Ray\\r\\n   * @param b Ray\\r\\n   * @return The result of a*b, in ray\\r\\n   **/\\r\\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    if (a == 0 || b == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    require(a <= (type(uint256).max - halfRAY) / b, \\\"MULTIPLICATION_OVERFLOW\\\");\\r\\n\\r\\n    return (a * b + halfRAY) / RAY;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Divides two ray, rounding half up to the nearest ray\\r\\n   * @param a Ray\\r\\n   * @param b Ray\\r\\n   * @return The result of a/b, in ray\\r\\n   **/\\r\\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    require(b != 0, \\\"DIVISION_BY_ZERO\\\");\\r\\n    uint256 halfB = b / 2;\\r\\n\\r\\n    require(a <= (type(uint256).max - halfB) / RAY, \\\"MULTIPLICATION_OVERFLOW\\\");\\r\\n\\r\\n    return (a * RAY + halfB) / b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Casts ray down to wad\\r\\n   * @param a Ray\\r\\n   * @return a casted to wad, rounded half up to the nearest wad\\r\\n   **/\\r\\n  function rayToWad(uint256 a) internal pure returns (uint256) {\\r\\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\\r\\n    uint256 result = halfRatio + a;\\r\\n    require(result >= halfRatio, \\\"ADDITION_OVERFLOW\\\");\\r\\n\\r\\n    return result / WAD_RAY_RATIO;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Converts wad up to ray\\r\\n   * @param a Wad\\r\\n   * @return a converted in ray\\r\\n   **/\\r\\n  function wadToRay(uint256 a) internal pure returns (uint256) {\\r\\n    uint256 result = a * WAD_RAY_RATIO;\\r\\n    require(result / WAD_RAY_RATIO == a, \\\"MULTIPLICATION_OVERFLOW\\\");\\r\\n    return result;\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0x66ec27b84b1e5fd32fcb02768b1794d147508a9ae007d7ad5c30231801b2c9f1\",\"license\":\"MIT\"},\"contracts/lendingpool/logic/GenericLogic.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\nimport \\\"../../types/DataTypes.sol\\\";\\r\\nimport \\\"../../helper/WadRayMath.sol\\\";\\r\\nimport \\\"../../helper/PercentageMath.sol\\\";\\r\\n\\r\\nlibrary GenericLogic {\\r\\n    using SafeMath for uint256;\\r\\n    using WadRayMath for uint256;\\r\\n    using PercentageMath for uint256;\\r\\n\\r\\n    uint256 public constant HEALTH_FACTOR_LIQUIDATION_THRESHOLD = 1 ether;\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev Calculates the health factor\\r\\n   * @param totalCollateral The total collateral in ETH\\r\\n   * @param totalDebt The total debt in ETH\\r\\n   * @param liquidationThreshold The liquidation threshold\\r\\n   * @return The health factor calculated from the balances provided\\r\\n   **/\\r\\n  function calculateHealthFactor(\\r\\n    uint256 totalCollateral,\\r\\n    uint256 totalDebt,\\r\\n    uint256 liquidationThreshold\\r\\n  ) internal pure returns (uint256) {\\r\\n    if (totalDebt == 0) return type(uint256).max;\\r\\n\\r\\n    return (totalCollateral.percentMul(liquidationThreshold)).wadDiv(totalDebt);\\r\\n  }\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev Calculates the equivalent amount in ETH that an user can borrow, depending on the available collateral and the\\r\\n   * average Loan To Value\\r\\n   * @param totalCollateral The total SFT amount as collateral\\r\\n   * @param totalDebt The total borrow balance\\r\\n   * @param ltv The loan to value\\r\\n   * @return the amount available FIL to borrow for the user\\r\\n   **/\\r\\n  function calculateAvailableBorrow(\\r\\n    uint256 totalCollateral,\\r\\n    uint256 totalDebt,\\r\\n    uint256 ltv\\r\\n  ) external pure returns (uint256) {\\r\\n    uint256 availableBorrows = totalCollateral.percentMul(ltv);\\r\\n\\r\\n    if (availableBorrows < totalDebt) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    availableBorrows = availableBorrows.sub(totalDebt);\\r\\n    return availableBorrows;\\r\\n  }\\r\\n}\",\"keccak256\":\"0xff8a7be0b8e567b12a067a574682fab36ca30b3d90c9d24aadb7d7000c2fdd97\",\"license\":\"MIT\"},\"contracts/types/DataTypes.sol\":{\"content\":\"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity 0.8.9;\\r\\n\\r\\nlibrary DataTypes {\\r\\n    struct ReserveData {\\r\\n        //the liquidity index. Expressed in ray\\r\\n        uint128 liquidityIndex;\\r\\n        //variable borrow index. Expressed in ray\\r\\n        uint128 variableBorrowIndex;\\r\\n        //the current supply rate. Expressed in ray\\r\\n        uint128 currentLiquidityRate;\\r\\n        //the current variable borrow rate. Expressed in ray\\r\\n        uint128 currentVariableBorrowRate;\\r\\n        uint40 lastUpdateTimestamp;\\r\\n        // fee percentage\\r\\n        uint16 reserveFactor; \\r\\n        // base point 10000\\r\\n        uint16 ltv;\\r\\n        uint16 liquidationThreshold;\\r\\n        //tokens addresses\\r\\n        address sFilTokenAddress;\\r\\n        address variableDebtTokenAddress;\\r\\n        //address of the interest rate strategy\\r\\n        address interestRateStrategyAddress;\\r\\n    }\\r\\n}\",\"keccak256\":\"0xbc3b0f7e784167a2139add05d4dedf7a3354a3ffa7fb20da2d8e9b5d076cb36e\",\"license\":\"agpl-3.0\"}},\"version\":1}",
  "bytecode": "0x61026961003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100405760003560e01c80631a6d1d7b14610045578063c3525c281461006a575b600080fd5b610058610053366004610181565b610079565b60405190815260200160405180910390f35b610058670de0b6b3a764000081565b60008061008685846100af565b90508381101561009a5760009150506100a8565b6100a48185610175565b9150505b9392505050565b60008215806100bc575081155b156100c95750600061016f565b816100d760026127106101c3565b6100e3906000196101e5565b6100ed91906101c3565b8311156101405760405162461bcd60e51b815260206004820152601760248201527f4d554c5449504c49434154494f4e5f4f564552464c4f57000000000000000000604482015260640160405180910390fd5b61271061014e6002826101c3565b61015884866101fc565b610162919061021b565b61016c91906101c3565b90505b92915050565b600061016c82846101e5565b60008060006060848603121561019657600080fd5b505081359360208301359350604090920135919050565b634e487b7160e01b600052601160045260246000fd5b6000826101e057634e487b7160e01b600052601260045260246000fd5b500490565b6000828210156101f7576101f76101ad565b500390565b6000816000190483118215151615610216576102166101ad565b500290565b6000821982111561022e5761022e6101ad565b50019056fea26469706673582212200dc751091226b129135a70d99946bae9cba23963d9baa172846604c616d57f7664736f6c63430008090033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100405760003560e01c80631a6d1d7b14610045578063c3525c281461006a575b600080fd5b610058610053366004610181565b610079565b60405190815260200160405180910390f35b610058670de0b6b3a764000081565b60008061008685846100af565b90508381101561009a5760009150506100a8565b6100a48185610175565b9150505b9392505050565b60008215806100bc575081155b156100c95750600061016f565b816100d760026127106101c3565b6100e3906000196101e5565b6100ed91906101c3565b8311156101405760405162461bcd60e51b815260206004820152601760248201527f4d554c5449504c49434154494f4e5f4f564552464c4f57000000000000000000604482015260640160405180910390fd5b61271061014e6002826101c3565b61015884866101fc565b610162919061021b565b61016c91906101c3565b90505b92915050565b600061016c82846101e5565b60008060006060848603121561019657600080fd5b505081359360208301359350604090920135919050565b634e487b7160e01b600052601160045260246000fd5b6000826101e057634e487b7160e01b600052601260045260246000fd5b500490565b6000828210156101f7576101f76101ad565b500390565b6000816000190483118215151615610216576102166101ad565b500290565b6000821982111561022e5761022e6101ad565b50019056fea26469706673582212200dc751091226b129135a70d99946bae9cba23963d9baa172846604c616d57f7664736f6c63430008090033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "calculateAvailableBorrow(uint256,uint256,uint256)": {
        "details": "Calculates the equivalent amount in ETH that an user can borrow, depending on the available collateral and the average Loan To Value",
        "params": {
          "ltv": "The loan to value",
          "totalCollateral": "The total SFT amount as collateral",
          "totalDebt": "The total borrow balance"
        },
        "returns": {
          "_0": "the amount available FIL to borrow for the user*"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}